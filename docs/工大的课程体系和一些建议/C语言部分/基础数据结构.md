# **数据结构**

数据结构是cs学生的内功，学好数据结构极其重要

## **链表**

### **单向链表**

#### **链表操作说明**
##### **创建链表函数**

为了创建一个链表，首先我们定义了一个结构体 ListNode，包含了整型变量 value 用于储存节点的值，以及指向下一个节点的指针 next。接着，我们定义了 NewList 函数，用于创建一个新的链表节点。这个函数使用 malloc 分配了一块堆空间，并初始化节点的值和指针。注意函数返回的是指向节点的指针。

```c linenums="1"
ListNode *NewList(int value)
{
    ListNode *node;
    node = (ListNode *)malloc(sizeof(ListNode));
    node->value = value;
    node->next = NULL;
    return node;
}
```

##### **插入节点函数**

为了在链表中插入一个新的节点，我们设计了 Insert 函数。该函数需要传入链表的头节点、要插入的节点以及插入的位置。函数通过遍历找到插入位置，将新节点插入到目标节点之后。

```c linenums="1"
void Insert(ListNode *head, ListNode *target, int index)
{
    while (head != NULL && head->next != NULL && index > 0)
    {
        head = head->next;
        index--;
    }
    target->next = head->next;
    head->next = target;
}
```
##### **遍历函数**

为了遍历链表，我们定义了 Access 函数。该函数需要传入链表的头节点和目标节点的索引，然后通过循环移动指针找到目标节点。

```c linenums="1"
ListNode *Access(ListNode *head, int index)
{
    while (head != NULL && head->next != NULL && index > 0)
    {
        head = head->next;
        index--;
    }
    return head;
}
```

##### **析构函数**

为了销毁整个链表，我们定义了 Delete 函数。该函数通过循环遍历链表，并使用 free 函数释放每个节点的内存。

```c linenums="1"
void Delete(ListNode *head)
{
    ListNode *tmp;
    while (head->next != NULL)
    {
        tmp = head;
        head = head->next;
        free(tmp);
    }
    free(head);
}
```

##### **创建链表函数**

最后，我们定义了 Create 函数，用于快速创建一个链表。该函数需要传入一个数组、数组长度以及一个存放链表节点的数组。函数通过遍历数组创建节点，并将节点之间连接起来形成链表。

```c linenums="1"
void Create(ListNode *n[], int val[], int len)
{
    for (int i = 0; i < len; i++)
    {
        n[i] = NewList(val[i]);
    }
    for (int i = 0; i < len - 1; i++)
    {
        n[i]->next = n[i + 1];
    }
}
```
##### **完整代码**

```c linenums="1"
#include <stdio.h>
#include <malloc.h>
// 所有节点序号从0开始，和数组一样
struct ListNode
{
    int value;             // 储存链表每个节点的值
    struct ListNode *next; // 一个和链表节点一样结构的结构指针，用来指向下一个节点
};
typedef struct ListNode ListNode;
ListNode *NewList(int);                    // 为什么要加*呢，因为我要返回一个指针，如果是返回一个结构就完蛋了，因为无法和下一个节点连起来
ListNode *Access(ListNode *, int);         // 输入头节点和节点序号，返回目标节点
void Delete(ListNode *);                   // 销毁一个链表
void Remove(ListNode *, int);              // 删掉某一个指定节点
void Insert(ListNode *, ListNode *, int);  // 插入第几号之后
int Find(ListNode *, int);                 // 查找节点值，查到了返回节点序号，没查到返回-1
void Create(ListNode *[], int[], int len); // 创建一个链表

int main()
{
    ListNode *n0, *n1, *n2, *n3, *in;
    ListNode *n[5];
    int val[] = {0, 11, 22, 33, 44};
    Create(n, val, 5);
    in = NewList(12345);
    Insert(n[0], in, 2);
    printf("%d", Access(n[0], 3)->value);
    return 0;
}
void Create(ListNode *n[], int val[], int len)
{
    for (int i = 0; i < len; i++)
    {
        n[i] = NewList(val[i]);
    }
    for (int i = 0; i < len - 1; i++)
    {
        n[i]->next = n[i + 1];
    }
}
ListNode *NewList(int value)
{
    ListNode *node;
    node = (ListNode *)malloc(sizeof(ListNode)); // 给node一点内存，大小就是一个结构的大小，类型是指针
    node->value = value;
    node->next = NULL; // 一定要有，不然无法判定是否到末尾了
    return node;
}
ListNode *Access(ListNode *head, int index)
{
    while (head != NULL && head->next != NULL && index > 0)
    {                      // 头节点不是空的、且下一个节点不是空的、且还没访问到目标节点的序号
        head = head->next; // 头节点就变成下一个节点了，然后继续循环
        index--;
    }
    return head; // 把头节点返回去就行，因为头节点已经指向了我们要找的节点
}
void Insert(ListNode *head, ListNode *target, int index)
{ // 插入第几号之后
    while (head != NULL && head->next != NULL && index > 0)
    {
        head = head->next;
        index--;
    }
    target->next = head->next; // 先让插入节点指下一个，然后再让前边的节点指插入的，如果不这样子链表会丢掉后面的所有节点
    head->next = target;
}
void Remove(ListNode *head, int index)
{
    while (head && head->next && index > 1)
    {
        head = head->next;
        index--;
    }
    ListNode *temp = head->next; // 直接将删除节点之前的一个节点指到删除节点之后，就完事了
    head->next = temp->next;
    free(temp); // 现在temp指的就是要删除的节点，free了就可以
}
void Delete(ListNode *head)
{
    ListNode *tmp;
    while (head->next != NULL) // 遍历到下一个，并且free掉刚才的那个节点
    {
        tmp = head;
        head = head->next;
        free(tmp);
    }
    free(head);
}
void Remove()
{
}
int Find(ListNode *head, int key)
{
    int index = 0;
    while (head != NULL)
    {
        if (head->value == key)
        {
            return index;
        }
        head = head->next;
        index++;
    }
    return -1;
}
```